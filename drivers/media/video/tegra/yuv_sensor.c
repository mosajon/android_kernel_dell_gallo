/*
 * kernel/drivers/media/video/tegra
 *
 * Aptina MT9D115 sensor driver
 *
 * Copyright (C) 2010 NVIDIA Corporation
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

#include <linux/delay.h>
#include <linux/fs.h>
#include <linux/i2c.h>
#include <linux/miscdevice.h>
#include <linux/slab.h>
#include <linux/uaccess.h>
#include <media/yuv_sensor.h>

struct sensor_reg {
	u16 addr;
	u16 val;
};

struct sensor_info {
	int mode;
	struct i2c_client *i2c_client;
	struct yuv_sensor_platform_data *pdata;
};

static struct sensor_info *info;

static int inited;

static struct sensor_reg mode_1600x1200[] = {
{0x098C, 0x2747},
{0x0990, 0x0000},
{0x098C, 0x2749},
{0x0990, 0x063F},
{0x098C, 0x274B},
{0x0990, 0x0000},
{0x098C, 0x274D},
{0x0990, 0x04AF},

{0x098C, 0x2723},
{0x0990, 0x0004},
{0x098C, 0x2725},
{0x0990, 0x0004},
{0x098C, 0x2727},
{0x0990, 0x04BB},
{0x098C, 0x2729},
{0x0990, 0x064B},

{0x098C, 0x2707},
{0x0990, 0x0640},
{0x098C, 0x2709},
{0x0990, 0x04B0},

{0x098C, 0xA103},
{0x0990, 0x0002},
{0x3400, 0x7A24},
{SENSOR_WAIT_MS, 100},
{SENSOR_TABLE_END, 0x0000}
};

static struct sensor_reg mode_640x480[] = {

{0x098C, 0x2739},
{0x0990, 0x0000},
{0x098C, 0x273B},
{0x0990, 0x031F},
{0x098C, 0x273D},
{0x0990, 0x0000},
{0x098C, 0x273F},
{0x0990, 0x0257},
{0x098C, 0x2703},
{0x0990, 0x0280},
{0x098C, 0x2705},
{0x0990, 0x01E0},
{0x098C, 0xA103},
{0x0990, 0x0005},
{0x3400, 0x7A20},
{SENSOR_TABLE_END, 0x0000}
};


static struct sensor_reg mode_800x600[] = {

{0x098C, 0x2739},
{0x0990, 0x0000},
{0x098C, 0x273B},
{0x0990, 0x031F},
{0x098C, 0x273D},
{0x0990, 0x0000},
{0x098C, 0x273F},
{0x0990, 0x0257},
{0x098C, 0x2703},
{0x0990, 0x0320},
{0x098C, 0x2705},
{0x0990, 0x0258},
{0x098C, 0xA103},
{0x0990, 0x0005},
{0x3400, 0x7A20},
{SENSOR_TABLE_END, 0x0000}
};

static struct sensor_reg mode_1280x720[] = {
{0x098C, 0x2747},
{0x0990, 0x0000},
{0x098C, 0x2749},
{0x0990, 0x063F},
{0x098C, 0x274B},
{0x0990, 0x0000},
{0x098C, 0x274D},
{0x0990, 0x0383},
{0x098C, 0x2723},
{0x0990, 0x009C},
{0x098C, 0x2725},
{0x0990, 0x0006},
{0x098C, 0x2727},
{0x0990, 0x0427},
{0x098C, 0x2729},
{0x0990, 0x064D},
{0x098C, 0x2707},
{0x0990, 0x0500},
{0x098C, 0x2709},
{0x0990, 0x02D0},
{0x098C, 0xA115},
{0x0990, 0x0072},
{0x098C, 0xA103},
{0x0990, 0x0002},
{0x3400, 0x7A20},
{SENSOR_WAIT_MS, 50},
{SENSOR_TABLE_END, 0x0000}

};

static struct sensor_reg mode_init[] = {
{0x001A, 0x0001},
{0x001A, 0x0000},
{SENSOR_WAIT_MS, 10},


{0x001A, 0x0050},
{0x001A, 0x0058},
{SENSOR_WAIT_MS, 1},
{0x0014, 0x21F9},
{0x0010, 0x0115},
{0x0012, 0x00F5},
{0x0014, 0x2545},
{0x0014, 0x2547},
{0x0014, 0x2447},
{SENSOR_WAIT_MS, 1},
{0x0014, 0x2047},
{0x0014, 0x2046},
{0x0018, 0x402D},
{0x0018, 0x402c},
{SENSOR_WAIT_MS, 10},

{0x98C, 0x2703},
{0x990, 0x0280},
{0x98C, 0x2705},
{0x990, 0x01E0},
{0x98C, 0x2707},
{0x990, 0x0640},
{0x98C, 0x2709},
{0x990, 0x04B0},
{0x98C, 0x270D},
{0x990, 0x0000},
{0x98C, 0x270F},
{0x990, 0x0000},
{0x98C, 0x2711},
{0x990, 0x04BD},
{0x98C, 0x2713},
{0x990, 0x064D},
{0x98C, 0x2715},
{0x990, 0x0111},
{0x98C, 0x2717},
{0x990, 0x046C},
{0x98C, 0x2719},
{0x990, 0x005A},
{0x98C, 0x271B},
{0x990, 0x01BE},
{0x98C, 0x271D},
{0x990, 0x0131},
{0x98C, 0x271F},
{0x990, 0x02BB},
{0x98C, 0x2721},
{0x990, 0x0888},
{0x98C, 0x2723},
{0x990, 0x0004},
{0x98C, 0x2725},
{0x990, 0x0004},
{0x98C, 0x2727},
{0x990, 0x04BB},
{0x98C, 0x2729},
{0x990, 0x064B},
{0x98C, 0x272B},
{0x990, 0x0111},
{0x98C, 0x272D},
{0x990, 0x0024},
{0x98C, 0x272F},
{0x990, 0x003A},
{0x98C, 0x2731},
{0x990, 0x00F6},
{0x98C, 0x2733},
{0x990, 0x008B},
{0x98C, 0x2735},
{0x990, 0x0521},
{0x98C, 0x2737},
{0x990, 0x0888},
{0x98C, 0x2739},
{0x990, 0x0000},
{0x98C, 0x273B},
{0x990, 0x031F},
{0x98C, 0x273D},
{0x990, 0x0000},
{0x98C, 0x273F},
{0x990, 0x0257},
{0x98C, 0x2747},
{0x990, 0x0000},
{0x98C, 0x2749},
{0x990, 0x063F},
{0x98C, 0x274B},
{0x990, 0x0000},
{0x98C, 0x274D},
{0x990, 0x04AF},

{0x98C, 0x2222},
{0x990, 0x00A0},
{0x98C, 0xA408},
{0x990, 0x0026},
{0x98C, 0xA409},
{0x990, 0x0029},
{0x98C, 0xA40A},
{0x990, 0x002E},
{0x98C, 0xA40B},
{0x990, 0x0031},
{0x98C, 0x2411},
{0x990, 0x00A0},
{0x98C, 0x2413},
{0x990, 0x00C0},
{0x98C, 0x2415},
{0x990, 0x00A0},
{0x98C, 0x2417},
{0x990, 0x00C0},

{0x098C, 0xA404},
{0x0990, 0x0010},
{0x098C, 0xA40D},
{0x0990, 0x0002},
{0x098C, 0xA40E},
{0x0990, 0x0003},
{0x098C, 0xA410},
{0x0990, 0x000A},


{0x098C, 0xA117},
{0x0990, 0x0002},
{0x098C, 0xA11D},
{0x0990, 0x0002},
{0x098C, 0xA129},
{0x0990, 0x0002},
{0x098C, 0xA24F},
{0x0990, 0x0046},
{0x098C, 0xA20C},
{0x0990, 0x0010},
{0x098C, 0xA216},
{0x0990, 0x0091},
{0x098C, 0xA20E},
{0x0990, 0x0091},
{0x098C, 0x2212},
{0x0990, 0x00A4},

{0x3210, 0x01B8 },
{0x098C, 0xAB36 },
{0x0990, 0x0014 },
{0x098C, 0x2B66 },
{0x0990, 0x2AF8 },
{0x098C, 0xAB20 },
{0x0990, 0x0080 },


{0x098C, 0xAB24 },

{0x0990, 0x0040 },

{0x098C, 0xAB21 },
{0x0990, 0x000A },
{0x098C, 0xAB25 },
{0x0990, 0x002A },
{0x098C, 0xAB22 },
{0x0990, 0x0007 },
{0x098C, 0xAB26 },
{0x0990, 0x0001 },
{0x098C, 0xAB23 },
{0x0990, 0x0004 },
{0x098C, 0xAB27 },
{0x0990, 0x0009 },
{0x098C, 0x2B28 },
{0x0990, 0x0BB8 },
{0x098C, 0x2B2A },
{0x0990, 0x2968 },
{0x098C, 0xAB2C },
{0x0990, 0x00FF },
{0x098C, 0xAB30 },
{0x0990, 0x00FF },
{0x098C, 0xAB2D },
{0x0990, 0x00FF },
{0x098C, 0xAB31 },
{0x0990, 0x00FF },
{0x098C, 0xAB2E },
{0x0990, 0x00FF },
{0x098C, 0xAB32 },
{0x0990, 0x00FF },
{0x098C, 0xAB2F },
{0x0990, 0x000A },
{0x098C, 0xAB33 },
{0x0990, 0x0006 },
{0x098C, 0xAB34 },
{0x0990, 0x0020 },
{0x098C, 0xAB35 },
{0x0990, 0x0091 },
{0x098C, 0xA765 },
{0x0990, 0x0006 },




{0x098C, 0xAB3C},
{0x0990, 0x0000},
{0x098C, 0xAB3D},
{0x0990, 0x000A},
{0x098C, 0xAB3E},
{0x0990, 0x001D},
{0x098C, 0xAB3F},
{0x0990, 0x0037},
{0x098C, 0xAB40},
{0x0990, 0x0058},
{0x098C, 0xAB41},
{0x0990, 0x0071},
{0x098C, 0xAB42},
{0x0990, 0x0086},
{0x098C, 0xAB43},
{0x0990, 0x0098},
{0x098C, 0xAB44},
{0x0990, 0x00A7},
{0x098C, 0xAB45},
{0x0990, 0x00B5},
{0x098C, 0xAB46},
{0x0990, 0x00C0},
{0x098C, 0xAB47},
{0x0990, 0x00CB},
{0x098C, 0xAB48},
{0x0990, 0x00D4},
{0x098C, 0xAB49},
{0x0990, 0x00DD},
{0x098C, 0xAB4A},
{0x0990, 0x00E4},
{0x098C, 0xAB4B},
{0x0990, 0x00EC},
{0x098C, 0xAB4C},
{0x0990, 0x00F3},
{0x098C, 0xAB4D},
{0x0990, 0x00F9},
{0x098C, 0xAB4E},
{0x0990, 0x00FF},

{0x098C, 0xAB37},
{0x0990, 0x0003},
{0x098C, 0x2B38},
{0x0990, 0x2968},
{0x098C, 0x2B3A},
{0x0990, 0x2D50},
{0x098C, 0x2B62},
{0x0990, 0xFFFE},
{0x098C, 0x2B64},
{0x0990, 0xFFFF},
{0x098C, 0xAB4F},
{0x0990, 0x0000},
{0x098C, 0xAB50},
{0x0990, 0x0013},
{0x098C, 0xAB51},
{0x0990, 0x0027},
{0x098C, 0xAB52},
{0x0990, 0x0043},
{0x098C, 0xAB53},
{0x0990, 0x0068},
{0x098C, 0xAB54},
{0x0990, 0x0081},
{0x098C, 0xAB55},
{0x0990, 0x0093},
{0x098C, 0xAB56},
{0x0990, 0x00A3},
{0x098C, 0xAB57},
{0x0990, 0x00B0},
{0x098C, 0xAB58},
{0x0990, 0x00BC},
{0x098C, 0xAB59},
{0x0990, 0x00C7},
{0x098C, 0xAB5A},
{0x0990, 0x00D1},
{0x098C, 0xAB5B},
{0x0990, 0x00DA},
{0x098C, 0xAB5C},
{0x0990, 0x00E2},
{0x098C, 0xAB5D},
{0x0990, 0x00E9},
{0x098C, 0xAB5E},
{0x0990, 0x00EF},
{0x098C, 0xAB5F},
{0x0990, 0x00F4},
{0x098C, 0xAB60},
{0x0990, 0x00FA},
{0x098C, 0xAB61},
{0x0990, 0x00FF},















{0x098C, 0x2306},
{0x0990, 0x01D6},
{0x098C, 0x2308},
{0x0990, 0xFF89},
{0x098C, 0x230A},
{0x0990, 0xFFA1},
{0x098C, 0x230C},
{0x0990, 0xFF73},
{0x098C, 0x230E},
{0x0990, 0x019C},
{0x098C, 0x2310},
{0x0990, 0xFFF1},
{0x098C, 0x2312},
{0x0990, 0xFFB0},
{0x098C, 0x2314},
{0x0990, 0xFF2D},
{0x098C, 0x2316},
{0x0990, 0x0223},
{0x098C, 0x2318},
{0x0990, 0x0024},
{0x098C, 0x231A},
{0x0990, 0x0038},
{0x098C, 0x231C},
{0x0990, 0x00BA},
{0x098C, 0x231E},
{0x0990, 0xFF67},
{0x098C, 0x2320},
{0x0990, 0xFFF6},
{0x098C, 0x2322},
{0x0990, 0xFFE0},
{0x098C, 0x2324},
{0x0990, 0x00AD},
{0x098C, 0x2326},
{0x0990, 0xFF9E},
{0x098C, 0x2328},
{0x0990, 0x0028},
{0x098C, 0x232A},
{0x0990, 0xFFDB},
{0x098C, 0x232C},
{0x0990, 0x0054},
{0x098C, 0x232E},
{0x0990, 0x0004},
{0x098C, 0x2330},
{0x0990, 0xFFF4},
{0x098C, 0x2332},
{0x0990, 0x025C},
{0x098C, 0x2334},
{0x0990, 0xFF06},
{0x098C, 0x2336},
{0x0990, 0xFFA0},
{0x098C, 0x2338},
{0x0990, 0xFF6C},
{0x098C, 0x233A},
{0x0990, 0x01F6},
{0x098C, 0x233C},
{0x0990, 0xFF9F},
{0x098C, 0x233E},
{0x0990, 0xFFE3},
{0x098C, 0x2340},
{0x0990, 0xFF47},
{0x098C, 0x2342},
{0x0990, 0x01D8},
{0x098C, 0x2344},
{0x0990, 0x0028},
{0x098C, 0x2346},
{0x0990, 0x002C},

{0x364E, 0x0290},
{0x3650, 0x9B0C},
{0x3652, 0x6512},
{0x3654, 0x360F},
{0x3656, 0xF393},
{0x3658, 0x7F8F},
{0x365A, 0xD888},
{0x365C, 0x0913},
{0x365E, 0x370E},
{0x3660, 0xF713},
{0x3662, 0x0090},
{0x3664, 0x4489},
{0x3666, 0x2592},
{0x3668, 0x760B},
{0x366A, 0xFB92},
{0x366C, 0x7E8F},
{0x366E, 0xDA8B},
{0x3670, 0x6B92},
{0x3672, 0x3E0F},
{0x3674, 0x8714},
{0x3676, 0x018E},
{0x3678, 0x9E0E},
{0x367A, 0xD290},
{0x367C, 0x540D},
{0x367E, 0x4193},
{0x3680, 0x360E},
{0x3682, 0x328D},
{0x3684, 0x9110},
{0x3686, 0xA50F},
{0x3688, 0x7913},
{0x368A, 0x498B},
{0x368C, 0x880D},
{0x368E, 0xE511},
{0x3690, 0x048E},
{0x3692, 0x6994},
{0x3694, 0x020D},
{0x3696, 0x650E},
{0x3698, 0xC390},
{0x369A, 0xF20E},
{0x369C, 0x3993},
{0x369E, 0x2313},
{0x36A0, 0xEF8E},
{0x36A2, 0x9396},
{0x36A4, 0x5612},
{0x36A6, 0x4C18},
{0x36A8, 0x3113},
{0x36AA, 0xA30F},
{0x36AC, 0xF395},
{0x36AE, 0x4513},
{0x36B0, 0x0F18},
{0x36B2, 0x0613},
{0x36B4, 0x8010},
{0x36B6, 0xDE95},
{0x36B8, 0x5813},
{0x36BA, 0x3698},
{0x36BC, 0x2113},
{0x36BE, 0xFB8F},
{0x36C0, 0x9296},
{0x36C2, 0x1113},
{0x36C4, 0x4C98},
{0x36C6, 0xA911},
{0x36C8, 0xFD0B},
{0x36CA, 0x0695},
{0x36CC, 0x548F},
{0x36CE, 0xBA97},
{0x36D0, 0xDE10},
{0x36D2, 0x370F},
{0x36D4, 0x0915},
{0x36D6, 0xC613},
{0x36D8, 0x8E18},
{0x36DA, 0xDC90},
{0x36DC, 0x1410},
{0x36DE, 0x6415},
{0x36E0, 0xBC14},
{0x36E2, 0xC198},
{0x36E4, 0xEF90},
{0x36E6, 0x6F8F},
{0x36E8, 0x7A94},
{0x36EA, 0xB794},
{0x36EC, 0xC897},
{0x36EE, 0x9B15},
{0x36F0, 0x2393},
{0x36F2, 0x3798},
{0x36F4, 0x8697},
{0x36F6, 0xA618},
{0x36F8, 0xDA14},
{0x36FA, 0x1F93},
{0x36FC, 0x7C96},
{0x36FE, 0xAA97},
{0x3700, 0x5299},
{0x3702, 0xF294},
{0x3704, 0x7212},
{0x3706, 0x3698},
{0x3708, 0xEE16},
{0x370A, 0xE499},
{0x370C, 0x9615},
{0x370E, 0x6D13},
{0x3710, 0x2D98},
{0x3712, 0x9F97},
{0x3714, 0xA198},
{0x3644, 0x0314},
{0x3642, 0x0264},
{0x3210, 0x01B8},

{0x098C, 0x0415},
{0x0990, 0xF601},
{0x0992, 0x42C1},
{0x0994, 0x0326},
{0x0996, 0x11F6},
{0x0998, 0x0143},
{0x099A, 0xC104},
{0x099C, 0x260A},
{0x099E, 0xCC04},
{0x098C, 0x0425},
{0x0990, 0x33BD},
{0x0992, 0xA362},
{0x0994, 0xBD04},
{0x0996, 0x3339},
{0x0998, 0xC6FF},
{0x099A, 0xF701},
{0x099C, 0x6439},
{0x099E, 0xFE01},
{0x098C, 0x0435},
{0x0990, 0x6918},
{0x0992, 0xCE03},
{0x0994, 0x25CC},
{0x0996, 0x0013},
{0x0998, 0xBDC2},
{0x099A, 0xB8CC},
{0x099C, 0x0489},
{0x099E, 0xFD03},
{0x098C, 0x0445},
{0x0990, 0x27CC},
{0x0992, 0x0325},
{0x0994, 0xFD01},
{0x0996, 0x69FE},
{0x0998, 0x02BD},
{0x099A, 0x18CE},
{0x099C, 0x0339},
{0x099E, 0xCC00},
{0x098C, 0x0455},
{0x0990, 0x11BD},
{0x0992, 0xC2B8},
{0x0994, 0xCC04},
{0x0996, 0xC8FD},
{0x0998, 0x0347},
{0x099A, 0xCC03},
{0x099C, 0x39FD},
{0x099E, 0x02BD},
{0x098C, 0x0465},
{0x0990, 0xDE00},
{0x0992, 0x18CE},
{0x0994, 0x00C2},
{0x0996, 0xCC00},
{0x0998, 0x37BD},
{0x099A, 0xC2B8},
{0x099C, 0xCC04},
{0x099E, 0xEFDD},
{0x098C, 0x0475},
{0x0990, 0xE6CC},
{0x0992, 0x00C2},
{0x0994, 0xDD00},
{0x0996, 0xC601},
{0x0998, 0xF701},
{0x099A, 0x64C6},
{0x099C, 0x03F7},
{0x099E, 0x0165},
{0x098C, 0x0485},
{0x0990, 0x7F01},
{0x0992, 0x6639},
{0x0994, 0x3C3C},
{0x0996, 0x3C34},
{0x0998, 0xCC32},
{0x099A, 0x3EBD},
{0x099C, 0xA558},
{0x099E, 0x30ED},
{0x098C, 0x0495},
{0x0990, 0x04BD},
{0x0992, 0xB2D7},
{0x0994, 0x30E7},
{0x0996, 0x06CC},
{0x0998, 0x323E},
{0x099A, 0xED00},
{0x099C, 0xEC04},
{0x099E, 0xBDA5},
{0x098C, 0x04A5},
{0x0990, 0x44CC},
{0x0992, 0x3244},
{0x0994, 0xBDA5},
{0x0996, 0x585F},
{0x0998, 0x30ED},
{0x099A, 0x02CC},
{0x099C, 0x3244},
{0x099E, 0xED00},
{0x098C, 0x04B5},
{0x0990, 0xF601},
{0x0992, 0xD54F},
{0x0994, 0xEA03},
{0x0996, 0xAA02},
{0x0998, 0xBDA5},
{0x099A, 0x4430},
{0x099C, 0xE606},
{0x099E, 0x3838},
{0x098C, 0x04C5},
{0x0990, 0x3831},
{0x0992, 0x39BD},
{0x0994, 0xD661},
{0x0996, 0xF602},
{0x0998, 0xF4C1},
{0x099A, 0x0126},
{0x099C, 0x0BFE},
{0x099E, 0x02BD},
{0x098C, 0x04D5},
{0x0990, 0xEE10},
{0x0992, 0xFC02},
{0x0994, 0xF5AD},
{0x0996, 0x0039},
{0x0998, 0xF602},
{0x099A, 0xF4C1},
{0x099C, 0x0226},
{0x099E, 0x0AFE},
{0x098C, 0x04E5},
{0x0990, 0x02BD},
{0x0992, 0xEE10},
{0x0994, 0xFC02},
{0x0996, 0xF7AD},
{0x0998, 0x0039},
{0x099A, 0x3CBD},
{0x099C, 0xB059},
{0x099E, 0xCC00},
{0x098C, 0x04F5},
{0x0990, 0x28BD},
{0x0992, 0xA558},
{0x0994, 0x8300},
{0x0996, 0x0027},
{0x0998, 0x0BCC},
{0x099A, 0x0026},
{0x099C, 0x30ED},
{0x099E, 0x00C6},
{0x098C, 0x0505},
{0x0990, 0x03BD},
{0x0992, 0xA544},
{0x0994, 0x3839},
{0x098C, 0x2006},
{0x0990, 0x0415},
{0x098C, 0xA005},
{0x0990, 0x0001},

{SENSOR_WAIT_MS, 50},
{0x0018, 0x0028},

{SENSOR_WAIT_MS, 50},
{0x098C, 0xA103},
{0x0990, 0x0006},
{SENSOR_TABLE_END, 0x0000}
};

enum {
	SENSOR_MODE_1600x1200,
	SENSOR_MODE_1280x720,
	SENSOR_MODE_640x480,
};

static struct sensor_reg *mode_table[] = {
	[SENSOR_MODE_1600x1200] = mode_1600x1200,
	[SENSOR_MODE_1280x720]  = mode_1280x720,
	[SENSOR_MODE_640x480]   = mode_640x480,
};


#if 0
static int sensor_read_reg(struct i2c_client *client, u16 addr, u16 *val)
{
	int err;
	struct i2c_msg msg[2];
	unsigned char data[4];

	if (!client->adapter)
		return -ENODEV;

	msg[0].addr = client->addr;
	msg[0].flags = 0;
	msg[0].len = 2;
	msg[0].buf = data;

	/* high byte goes out first */
	data[0] = (u8) (addr >> 8);;
	data[1] = (u8) (addr & 0xff);

	msg[1].addr = client->addr;
	msg[1].flags = I2C_M_RD;
	msg[1].len = 2;
	msg[1].buf = data + 2;

	err = i2c_transfer(client->adapter, msg, 2);

	if (err != 2)
		return -EINVAL;

	*val = data[2];
	swab16(*val);

	return 0;
}
#endif


static int sensor_write_reg(struct i2c_client *client, u16 addr, u16 val)
{
	int err;
	struct i2c_msg msg;
	unsigned char data[4];
	int retry = 0;

	if (!client->adapter)
		return -ENODEV;

	data[0] = (u8) (addr >> 8);
	data[1] = (u8) (addr & 0xff);
	data[2] = (u8) (val >> 8);
	data[3] = (u8) (val & 0xff);

	msg.addr = client->addr;
	msg.flags = 0;
	msg.len = 4;
	msg.buf = data;

	do {
		err = i2c_transfer(client->adapter, &msg, 1);
		if (err == 1)
			return 0;
		retry++;
		pr_err("yuv_sensor : i2c transfer failed, retrying %x %x\n",
		       addr, val);
		msleep(20);
	} while (retry <= SENSOR_MAX_RETRIES);

	return err;
}

static int sensor_write_table(struct i2c_client *client,
			      const struct sensor_reg table[])
{
	int err;
	const struct sensor_reg *next;
	u16 val;

	pr_info("yuv %s\n", __func__);
	for (next = table; next->addr != SENSOR_TABLE_END; next++) {
		if (next->addr == SENSOR_WAIT_MS) {
			msleep(next->val);
			continue;
		}

		val = next->val;

		err = sensor_write_reg(client, next->addr, val);
		if (err)
			return err;
	}
	return 0;
}

static int sensor_set_mode(struct sensor_info *info, struct sensor_mode *mode)
{
	int sensor_table;
	int err;

	pr_info("%s: xres %u yres %u\n", __func__, mode->xres, mode->yres);

	if (mode->xres == 1600 && mode->yres == 1200)
		sensor_table = SENSOR_MODE_1600x1200;
	else if (mode->xres == 1280 && mode->yres == 720)
		sensor_table = SENSOR_MODE_1280x720;
	else if (mode->xres == 640 && mode->yres == 480)
		sensor_table = SENSOR_MODE_640x480;
	else {
		pr_err("%s: invalid resolution supplied to set mode %d %d\n",
		       __func__, mode->xres, mode->yres);
		return -EINVAL;
	}

	if (inited == 0) {
		err = sensor_write_table(info->i2c_client, mode_init);
		if (err)
			return err;
	}

	err = sensor_write_table(info->i2c_client, mode_table[sensor_table]);
	if (err)
		return err;

	inited = 1;
	info->mode = sensor_table;
	return 0;
}

static long sensor_ioctl(struct file *file,
			 unsigned int cmd, unsigned long arg)
{
	struct sensor_info *info = file->private_data;

	pr_info("yuv %s\n", __func__);
	switch (cmd) {
	case SENSOR_IOCTL_SET_MODE:
	{
		struct sensor_mode mode;
		if (copy_from_user(&mode,
				   (const void __user *)arg,
				   sizeof(struct sensor_mode))) {
			return -EFAULT;
		}

		return sensor_set_mode(info, &mode);
	}
	case SENSOR_IOCTL_GET_STATUS:
	{

		return 0;
	}
	default:
		return -EINVAL;
	}
	return 0;
}

static int sensor_open(struct inode *inode, struct file *file)
{
	pr_info("yuv %s\n", __func__);
	file->private_data = info;
	if (info->pdata && info->pdata->power_on)
		info->pdata->power_on();
	inited = 0;
	return 0;
}

int sensor_release(struct inode *inode, struct file *file)
{
	if (info->pdata && info->pdata->power_off)
		info->pdata->power_off();
	file->private_data = NULL;
	inited = 0;
	return 0;
}


static const struct file_operations sensor_fileops = {
	.owner = THIS_MODULE,
	.open = sensor_open,
	.unlocked_ioctl = sensor_ioctl,
	.release = sensor_release,
};

static struct miscdevice sensor_device = {
	.minor = MISC_DYNAMIC_MINOR,
	.name = SENSOR_NAME,
	.fops = &sensor_fileops,
};

static int sensor_probe(struct i2c_client *client,
			const struct i2c_device_id *id)
{
	int err;

	pr_info("yuv %s\n", __func__);

	info = kzalloc(sizeof(struct sensor_info), GFP_KERNEL);

	if (!info) {
		pr_err("yuv_sensor : Unable to allocate memory!\n");
		return -ENOMEM;
	}

	err = misc_register(&sensor_device);
	if (err) {
		pr_err("yuv_sensor : Unable to register misc device!\n");
		kfree(info);
		return err;
	}

	info->pdata = client->dev.platform_data;
	info->i2c_client = client;

	i2c_set_clientdata(client, info);
	return 0;
}

static int sensor_remove(struct i2c_client *client)
{
	struct sensor_info *info;

	pr_info("yuv %s\n", __func__);
	info = i2c_get_clientdata(client);
	misc_deregister(&sensor_device);
	kfree(info);
	return 0;
}

static const struct i2c_device_id sensor_id[] = {
	{ SENSOR_NAME, 0 },
	{ },
};

MODULE_DEVICE_TABLE(i2c, sensor_id);

static struct i2c_driver sensor_i2c_driver = {
	.driver = {
		.name = SENSOR_NAME,
		.owner = THIS_MODULE,
	},
	.probe = sensor_probe,
	.remove = sensor_remove,
	.id_table = sensor_id,
};

static int __init sensor_init(void)
{
	pr_info("yuv %s\n", __func__);
	return i2c_add_driver(&sensor_i2c_driver);
}

static void __exit sensor_exit(void)
{
	pr_info("yuv %s\n", __func__);
	i2c_del_driver(&sensor_i2c_driver);
}

module_init(sensor_init);
module_exit(sensor_exit);

